import asyncio
import json
import logging
import logging.config
import traceback

from autobahn.asyncio.websocket import WebSocketClientFactory
from urllib import parse as urlparse

from ...common.ws.protocol import register_ws_callback, AgentWebSocketCallbackType, AgentWebSocketClientProtocol
from .....utils import helper as hlp
from .....utils.constants import WS_SIMULATE as SIMULATE


class AgentWebsocketClient(object):
    """
    Class to handle trading agents websocket communication.
    """

    def __init__(self, name, account, email, password, marketplace, address, port, path, queue, ssl=False):
        """
        Initialisation of the class.

        :param name: Name of the trading agent. Useful for logging purposes.
        :param account: Account name for the login.
        :param password: Account password for the login (not used at the moment).
        :param marketplace: Marketplace id for the messages.
        :param address: Address if the websocket connection.
        :param port: Port for the websocket connection.
        :param queue: Queue for incoming messages.
        """

        assert (ssl and port == 443) or (not ssl and port != 443), f"WS port cannot be {port} if SSL is {ssl}"

        self._loop = asyncio.get_event_loop()
        self._name = name
        self._account = account
        self._email = email
        self._password = password
        self._marketplace = marketplace
        self._address = address.rstrip('/')
        self._port = port
        self._path = path.strip('/') + '/'
        self._ssl = ssl
        self._incoming_message_queue = queue
        self._stop = False
        self._logger = None
        self._is_ready = False
        self._waiting_to_join = False
        self._client_protocol = None
        self._channel_id = None
        self._outgoing_message_queue = asyncio.Queue()
        self._setup_logging()

        self._ws_scheme = 'wss' if ssl else 'ws'
        self._base_uri = f"{self._ws_scheme}://{self._address}:{self._port}"
        self._ws_endpoint = urlparse.urljoin(self._base_uri, self._path)

        # Register callbacks
        type(self).incoming = register_ws_callback(AgentWebSocketCallbackType.MESSAGE, self)(type(self).incoming)
        # type(self).lost_connection = register_ws_callback(AgentWebSocketCallbackType.CLOSE, self)(type(self).lost_connection)

    def _setup_logging(self):
        self._logger = logging.getLogger(".".join(["ws", 'AH', hlp.str_shorten(self._name)]))
        # self._logger.setLevel(logging.DEBUG)  # Dev Only

    def _get_connection_task(self):
        """
        Create the connection task that will connect to the websocket server
        :return:
        """
        factory = WebSocketClientFactory(self._ws_endpoint)
        factory.protocol = AgentWebSocketClientProtocol
        task = self._loop.create_connection(factory, self._address, self._port, ssl=self._ssl)
        return task

    def send_message(self, message, msg_type):
        """
        Adds the string message to the queue.
        Important! The structuring of the message (e.g., inclusion of channel id, is done in the queue and not here).
        This is because we may be waiting for certain information to create a valid message structure.
        :param message: String message
        :param msg_type: Type of message as string
        :return:
        """
        if not SIMULATE:
            self._outgoing_message_queue.put_nowait((message, msg_type))

    def setup(self):
        try:
            self._logger.debug(f"Connecting to websocket at {self._ws_endpoint}")
            transport, self._client_protocol = self._loop.run_until_complete(self._get_connection_task())
            self._client_protocol.client = self
            self._logger.debug(f"Connection task complete: {transport} {self._client_protocol}")
            asyncio.run_coroutine_threadsafe(self._process_message_queue(), self._loop)
            self._logger.debug('Setup finished')
        except (ConnectionError, OSError):
            self._logger.debug(traceback.format_exc())
            self._logger.error(f"Cannot connect to websocket at `{self._ws_endpoint}`")

    async def _process_message_queue(self):
        """
        Consumer for the outgoing messages to the websocket server.
        Important! We pull a string message to the queue and structure to it (e.g., channel id, command, and time).
        The channel id is only available after joining the appropriate channel on the server. This method waits for
        the channel id to be set (via the _is_ready variable) before sending the messages.
        :return:
        """
        while not self.stop:
            if not self._is_ready:
                self._logger.debug('Try to login')
                await asyncio.gather(self._login())
            self._logger.debug('Login finished')

            if self._is_ready and not self._outgoing_message_queue.empty():
                message, msg_type = await self._outgoing_message_queue.get()
                outgoing_message = {
                    "channel_id": self._channel_id,
                    "message": message,
                    "command": "send",
                    "source": "robot",
                    "message_type": msg_type,
                    "time": hlp.time_milli(),  # time.strftime('[%d-%m-%y] %H:%M:%S')}
                }

                self._client_protocol.send_message(outgoing_message, encoder=lambda x: json.dumps(x, default=lambda o: str(o)))

            await asyncio.sleep(0.2)

    async def _login(self):
        """
        Login to the server and send a join message after the client protocol is connected to the websocket server.
        If we don't wait for the websocket connection, the login message will be lost.
        The join message is essential to pair the messages with the correct "chat room".
        :return:
        """
        # send a login if only we are not already waiting for a previous message
        if not self._waiting_to_join and not self.stop:
            self._waiting_to_join = True
            self._logger.debug('Attempt to login')

            while not self._client_protocol.is_connected:
                self._logger.debug('Wait for protocol to connect')
                try:
                    await asyncio.sleep(1)
                except KeyboardInterrupt:
                    self._logger.error("KeyboardInterrupt received while connecting to WebSockets server")

            self._logger.debug('Protocol connected')
            message = {
                "command": "join",
                "source": "robot",
                "username": f"{self._account}|{self._email}",
                "marketplace": self._marketplace,
            }

            if not self._is_ready:
                self._logger.debug('Trying to join')
                self._client_protocol.send_message(message, encoder=lambda x: json.dumps(x, default=lambda o: str(o)))
                await asyncio.sleep(1)

    def _logout(self):
        """
        Logout from the server indicating that the bot is about to stop.
        :return:
        """
        # send a login if only we are not already waiting for a previous message
        if self._is_ready:
            message = {
                "command": "leave",
                "source": "robot",
                "channel_id": self._channel_id,
                "username": f"{self._account}|{self._email}",
                "marketplace": self._marketplace
            }
            self._client_protocol.send_message(message, encoder=lambda x: json.dumps(x, default=lambda o: str(o)))

    def incoming(self, message):
        message = json.loads(message)
        if not self._is_ready and "join" in message.keys():
            self._channel_id = int(message["join"])
            self._is_ready = True
            self._waiting_to_join = False
            self.send_message(f"{self._name} is connected to websocket server.", "INFO")
            self._logger.debug("Ready to send websocket messages.")
        else:
            self._incoming_message_queue.put_nowait(message)

    def lost_connection(self, code, reason):
        self._is_ready = False

        async def _re_connect():
            if not self.stop:
                self._logger.debug("Reconnecting to the hosting websocket server")
                # while not self._is_ready:
                try:
                    connection_task = self._loop.create_task(self._get_connection_task())
                    transport, self._client_protocol = await connection_task
                    self._client_protocol.client = self

                    # login_task = self._loop.create_task(self._login())
                    # await login_task
                    await asyncio.gather(self._login())
                except ConnectionError:
                    # give the server two seconds to start accepting connections again
                    await asyncio.sleep(2)

        asyncio.gather(_re_connect())

    @property
    def stop(self):
        return self._stop

    @stop.setter
    def stop(self, value):
        self._stop = bool(value)
        self._logout()
